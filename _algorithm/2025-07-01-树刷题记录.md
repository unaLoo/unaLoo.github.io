---
title: "树刷题记录"
date: 2025-07-01
permalink: /algorithm/tree/
tags:
  - 数据结构
---
> 树刷题记录

---- 

## 二叉树前中后序的非递归遍历法

空指针标记法，通过null标记，把遍历过程和处理过程分离开来

### 中序遍历
```js
var inorderTraversal = function (root) {
    if (root == null) return []

    let res = []
    let stack = []
    stack.push(root)

    while (stack.length) {

        let node = stack.pop()

        if (node != null) { // 遇到了-新节点- , 不处理当前节点 ,右根左入栈

            if (node.right) stack.push(node.right)

            stack.push(node)
            stack.push(null) // 遇到null的话，就处理前一个节点

            if (node.left) stack.push(node.left)
        }
        else {
            // node === null
            res.push(stack.pop().val) // 直接处理前一个节点
        }

    }

    return res
};
```


### 前序遍历
因为前序遍历里，遍历过程和处理过程是同步的, 所以可以删减空指针的逻辑
```js
var preorderTraversal = function (root) {
    if (root == null) return []

    const stack = []
    const res = []
    stack.push(root)

    while (stack.length) {

        const node = stack.pop()

        if (node !== null) {
            // 遇到新节点，右左根入栈，
            if (node.right) stack.push(node.right)
            if (node.left) stack.push(node.left)
            // stack.push(node)
            // stack.push(null)
            res.push(node.val)
        }

        // else {
        //     res.push(stack.pop().val)
        // }
    }
    return res
};
```

### 后序遍历
```js 
var postorderTraversal = function (root) {
    if (!root) return []

    const stack = []
    const res = []
    stack.push(root)

    while (stack.length) {

        const node = stack.pop()

        if (node != null) {
            // 遍历遇到新节点，不急着处理，根右左入栈
            stack.push(node)
            stack.push(null)
            if (node.right) stack.push(node.right)
            if (node.left) stack.push(node.left)
        }
        else {
            res.push(stack.pop().val)
        }
    }
    return res
};
```

## 